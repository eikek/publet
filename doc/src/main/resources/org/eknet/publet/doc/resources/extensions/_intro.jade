- import org.eknet.publet.doc.SourceHelper
:markdown
  # Extensions

  Extensions are packaged jar files that contain code, templates and other
  resources that add extra functionality to publet. Publet is distributed with
  some extensions already.

  The _web-editor_, for example, is included by using the extension concept.

  In order to create new extensions, you need to know a little about how components
  are wired.

  ## Guice Modules

  The different application components are wired using [Guice](http://code.google.com/p/google-guice/)
  dependency injection framework. The "container" is created by creating an `Injector` at
  application start. This injector contains the default bindings of the application and extensions
  can contribute other bindings easily by creating a module that extends the `PubletModule`
  trait. This trait extends the `Module` interface from guice not adding other members. It's
  just for marking guice modules that should considered as extensions to publet.

  The modules are lookup up at application start using [Java's ServiceLoader](http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html)
  strategy. Thus, to add a new module create a file

      META-INF/services/org.eknet.publet.web.guice.PubletModule

  and add lines denoting the full classname of your modules. The module must have a no-arg constructor
  in order to get instantiated. There is another trait `PubletBindings` that defines some helper
  methods for creating bindings.

  That means, that all such provided modules are automatically added to the injector. If you want to
  prevent certain modules from being loaded, specify them in the configuration file `publet.properties`.
  Please use the full class name of the published module class with an associated value of `false`. For
  example, you could exclude the webeditor by specifying

      org.eknet.publet.webeditor.WebeditorModule=false

  in the configuration file.

  This is the only way to contribute to the application, but using guice bindings it is possible
  to contribute to existing services. There are a few hooks available:

  ### Events

  Publet uses an event bus to publish events. You can listen for any event just by registering
  an object to the `EventBus` that has `@Subscribe` annotated methods expecting the desired event
  as its only argument. Registering is quite easy, since all services created by guice are registerd
  on the `EventBus`. Thus, you only need to create a class with the appropriate event handler methods
  and bind them in your module.

  For example, to mount additional resources into the content tree, the `PubletStartedEvent` can
  be used. This is published once on application start.


  ### The trait _WebExtension_

  This trait can be used to intercept standard request processing. It looks as
  follows:

pre
  code.scala<>
    !~~SourceHelper.printSource("WebExtension.scala")

:markdown
  This way you can wrap the request before it goes to the final processing phase.

  You need to bind you `WebExtension` using a `Multibinder` such that it is added to the
  existing set of extensions. When using the helper trait `PubletBindings` this can be
  done like that:

      binder.bindExtension.toType[MyWebExtension]

  or just use guice's `Multibinder.newSetBinder` with the type `WebExtension`.


  ### RequestHandler

  All requests are dispatched to a specific request handler that has been registered with guice. Each
  request is handed to a `RequestHandlerFactory` in order to find a match. If a match is found, the
  request is handed off to the handler.

  You can add custom handlers by binding a `RequestHandlerFactory` in your module.

      binder.bindRequestHandler.toType[GitHandlerFactory]

  The trait looks like this:

pre
  code.scala<>
    !~~SourceHelper.printSource("RequestHandlerFactory.scala")

:markdown

  A `RequestHandlerFactory` is asked to create a `javax.servlet.Filter` that handles a request. This
  filter is only applied, if the request matches this handler. That is, it returns the highest score
  for the current request. To ease writing new filters, the `SuperFilter` class can be used to create
  a filter that itself is a filter chain. The object `Filters` collects some pre-defined filters that
  can be reused, if applicable.

  Please have a look at the provided implementations for more information.

  ### Realms

  The same way `WebExtension` and `RequestHandlerFactory` are contributed, you can contribute
  shiro `Realm` objects. If you have an user database, just implement a `Realm` and bind it in
  your module to the set of Realms.

      binder.bindRealm.toType[UsersRealm]


  ## Installing Extensions

  Extensions are installed by including them in the classpath. For a war file, that means using
  the "exploded war" mode and dropping the jar file into `WEB-INF/lib`.

  When using the standalone server, drop it in the directory `plugins`. You
  might need to create it first (next to the `etc` directory).